name: "Cybr Build"

on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - iso-only
      skip_base:
        description: 'Skip base system build (faster ISO-only builds)'
        required: false
        default: false
        type: boolean
  push:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * 0'

jobs:
  build-base:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    outputs:
      base_name: ${{ steps.set-names.outputs.base_name }}
      iso_name: ${{ steps.set-names.outputs.iso_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Set build names
        id: set-names
        run: |
          echo "base_name=cybr-base-v${{ github.run_number }}" >> $GITHUB_OUTPUT
          echo "iso_name=cybr-netinstall-v${{ github.run_number }}" >> $GITHUB_OUTPUT

      - name: Free disk space
        if: ${{ inputs.build_type != 'iso-only' && !inputs.skip_base }}
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost /opt/hostedtoolcache
          sudo docker system prune -af --volumes
          sudo apt-get autoremove -y && sudo apt-get clean

      - name: Build Cybr Base System
        if: ${{ inputs.build_type != 'iso-only' && !inputs.skip_base }}
        run: |
          BASE_NAME="${{ steps.set-names.outputs.base_name }}"
          docker run --rm --privileged -v "$PWD:/w" -e BASE_NAME="${BASE_NAME}" debian:bookworm bash -c '
          set -e
          export DEBIAN_FRONTEND=noninteractive
          apt-get update && apt-get install -y debootstrap squashfs-tools wget curl gnupg2
          
          debootstrap --arch=amd64 --variant=minbase bookworm base http://deb.debian.org/debian/
          
          chroot base bash <<'"'"'EOF'"'"'
          export DEBIAN_FRONTEND=noninteractive
          
          cat > /etc/apt/sources.list <<SOURCES
          deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware
          SOURCES
          
          apt-get update && apt-get install -y curl gnupg2 ca-certificates
          
          mkdir -p /usr/share/keyrings
          curl -fsSL https://liquorix.net/liquorix-keyring.gpg -o /usr/share/keyrings/liquorix-archive-keyring.gpg
          cat > /etc/apt/sources.list.d/liquorix.sources <<LIQUORIX
          Types: deb
          URIs: https://liquorix.net/debian
          Suites: bookworm
          Components: main
          Architectures: amd64
          Signed-By: /usr/share/keyrings/liquorix-archive-keyring.gpg
          LIQUORIX
          
          apt-get update
          apt-get install -y linux-image-liquorix-amd64 firmware-linux-free firmware-linux-nonfree systemd sudo phosh-full gdm3 network-manager firefox-esr flatpak gparted ntfs-3g dosfstools e2fsprogs nano
          
          dpkg --add-architecture i386 && apt-get update
          apt-get install -y steam libgl1-mesa-dri:amd64 libgl1-mesa-dri:i386 mesa-vulkan-drivers:amd64 mesa-vulkan-drivers:i386
          
          wget -O /tmp/discord.deb "https://discord.com/api/download?platform=linux&format=deb"
          apt-get install -y /tmp/discord.deb || apt-get install -f -y
          
          cat > /etc/os-release <<OSREL
          NAME="Cybr"
          PRETTY_NAME="Cybr Mobile Gaming Edition"
          ID=cybr
          ID_LIKE=debian
          VERSION_ID="1.0"
          HOME_URL="https://getcybr.org/"
          OSREL
          
          useradd -m -s /bin/bash -G sudo,audio,video,netdev cybruser
          echo "cybruser:cybr" | chpasswd
          echo "root:root" | chpasswd
          
          mkdir -p /etc/gdm3
          echo -e "[daemon]\nAutomaticLoginEnable=true\nAutomaticLogin=cybruser" > /etc/gdm3/custom.conf
          
          systemctl enable gdm3 NetworkManager
          apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
          EOF
          
          mksquashfs base "${BASE_NAME}.squashfs" -comp xz -b 1M -Xdict-size 100%
          mv "${BASE_NAME}.squashfs" /w/
          '

      - name: Build iPXE BIOS+UEFI Installer ISO
        run: |
          ISO_NAME="${{ steps.set-names.outputs.iso_name }}"
          docker run --rm --privileged -v "$PWD:/w" -e ISO_NAME="${ISO_NAME}" debian:bookworm bash -c '
          set -e
          export DEBIAN_FRONTEND=noninteractive
          apt-get update && apt-get install -y wget cpio xorriso isolinux syslinux-utils squashfs-tools dosfstools grub-efi-amd64-bin mtools git build-essential liblzma-dev
          echo "deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware" > /etc/apt/sources.list
          apt-get update && apt-get install -y linux-image-amd64 firmware-iwlwifi wpasupplicant parted iw
          cd /tmp
          
          # Get kernel
          cp "$(find /boot -name "vmlinuz-*" | tail -1)" vmlinuz
          
          # Build iPXE with embedded script
          git clone --depth 1 https://github.com/ipxe/ipxe.git
          cd ipxe/src
          
          cat > embed.ipxe <<"IPXE"
          #!ipxe
          dhcp || goto retry
          :retry
          echo Network configuration...
          dhcp && goto menu || goto manual
          
          :manual
          echo Manual network setup
          set idx:int8 0
          :loop isset ${net${idx}/mac} || goto menu
          echo [${idx}] ${net${idx}/mac} ${net${idx}/chip}
          inc idx && goto loop
          
          :menu
          menu Cybr Installer
          item --gap Network
          item wifi Configure WiFi
          item eth Configure Ethernet
          item --gap Actions  
          item install Install Cybr to Disk
          item shell iPXE Shell
          item reboot Reboot
          choose option && goto ${option}
          
          :wifi
          echo WiFi configuration via iPXE is limited
          echo Please use ethernet or boot to installer shell
          goto menu
          
          :eth
          dhcp || echo DHCP failed
          goto menu
          
          :install
          echo Booting installer kernel...
          kernel http://boot.ipxe.org/demo/boot.php || kernel vmlinuz initrd=initrd.gz || goto menu
          boot || goto menu
          
          :shell
          shell
          
          :reboot
          reboot
          IPXE
          
          # Build iPXE BIOS
          make bin/ipxe.lkrn EMBED=embed.ipxe -j$(nproc)
          
          # Build iPXE UEFI
          make bin-x86_64-efi/ipxe.efi EMBED=embed.ipxe -j$(nproc)
          
          cp bin/ipxe.lkrn /tmp/ipxe-bios.lkrn
          cp bin-x86_64-efi/ipxe.efi /tmp/ipxe-uefi.efi
          cd /tmp
          
          # Get busybox & create minimal initramfs
          wget -qO busybox https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox && chmod +x busybox
          mkdir -p i/{bin,sbin,proc,sys,dev,mnt,etc,lib/{firmware/iwlwifi,x86_64-linux-gnu},lib64}
          cp busybox i/bin/
          cd i/bin && for c in sh mount umount cat wget ping ip grep reboot; do ln -s busybox $c; done
          cd ../sbin && for c in init mdev udhcpc; do ln -s ../bin/busybox $c; done && cd /tmp
          
          # Copy minimal firmware (only 5 most common Intel WiFi files)
          for f in iwlwifi-7260-17.ucode iwlwifi-8000C-36.ucode iwlwifi-8265-36.ucode iwlwifi-9000-pu-b0-jf-b0-46.ucode iwlwifi-QuZ-a0-hr-b0-77.ucode; do
            cp /lib/firmware/iwlwifi/$f i/lib/firmware/iwlwifi/ 2>/dev/null || true
          done
          
          # Copy only critical tools
          cp /sbin/wpa_supplicant /sbin/parted /sbin/iw i/sbin/ 2>/dev/null
          cp /usr/sbin/unsquashfs i/sbin/ 2>/dev/null || true
          strip i/sbin/* 2>/dev/null || true
          
          # Copy minimal libs
          cp /lib64/ld-linux-x86-64.so.2 i/lib64/
          for lib in libc.so.6 libm.so.6 libnl-3.so.200 libnl-genl-3.so.200 libdbus-1.so.3 libblkid.so.1 libuuid.so.1 libz.so.1 liblzma.so.5 libresolv.so.2 libnss_dns.so.2; do
            find /lib /usr/lib -name "$lib" 2>/dev/null | head -1 | xargs -I{} cp {} i/lib/x86_64-linux-gnu/ && strip i/lib/x86_64-linux-gnu/$lib 2>/dev/null || true
          done
          
          # Minimal network config
          echo "nameserver 8.8.8.8" > i/etc/resolv.conf
          
          cat > i/init <<"EOF"
          #!/bin/sh
          export PATH=/bin:/sbin LD_LIBRARY_PATH=/lib/x86_64-linux-gnu:/lib64
          mount -t proc none /proc;mount -t sysfs none /sys;mount -t devtmpfs none /dev;mdev -s;hostname cybr;clear
          echo "=== Cybr Installer ==="
          echo "Commands: wifi | eth | install | shell | reboot"
          echo
          eth(){ E=$(ip link|grep -oE "e[a-z0-9]*"|head -1);ip link set $E up;udhcpc -i $E -qn;ping -c1 8.8.8.8>/dev/null&&echo "Ethernet: OK"||echo "Ethernet: FAIL"; }
          wifi(){ W=$(ip link|grep -o "wl[^:]*"|head -1);ip link set $W up;sleep 1;read -p "SSID: " S;read -sp "Password: " P;echo;echo -e "network={\nssid=\"$S\"\npsk=\"$P\"\n}">/tmp/w;wpa_supplicant -B -i $W -c /tmp/w;sleep 3;udhcpc -i $W -qn;ping -c1 8.8.8.8>/dev/null&&echo "WiFi: OK"||echo "WiFi: FAIL"; }
          inst(){ ping -c1 8.8.8.8>/dev/null||{ echo "ERROR: No network connection";return; };echo;lsblk -do NAME,SIZE,TYPE|grep disk;echo;read -p "Target disk (e.g. sda): " D;D="/dev/$D";[ ! -b "$D" ]&&{ echo "ERROR: Invalid disk";return; };echo;echo "WARNING: This will ERASE $D";read -p "Type YES to confirm: " C;[ "$C" != "YES" ]&&{ echo "Cancelled";return; };echo "Partitioning $D...";parted -s $D mklabel gpt mkpart ESP fat32 1M 513M mkpart primary ext4 513M 100% set 1 esp on||{ echo "Partition failed";return; };sleep 2;echo "Creating filesystems...";mkfs.vfat -F32 ${D}1>/dev/null;mkfs.ext4 -F ${D}2>/dev/null;mount ${D}2 /mnt;mkdir -p /mnt/boot/efi;mount ${D}1 /mnt/boot/efi;U="https://sourceforge.net/projects/wolfos/files/gaming/base";echo "Fetching latest base...";L=$(wget -qO- $U|grep -oP "cybr-base-v\d+"|sort -V|tail -1);[ -z "$L" ]&&{ echo "ERROR: Could not find base image";umount -R /mnt;return; };echo "Downloading $L.squashfs...";wget -qO /tmp/b.sq "$U/$L.squashfs/download"||{ echo "Download failed";umount -R /mnt;return; };echo "Extracting base system (this takes a few minutes)...";unsquashfs -f -d /mnt /tmp/b.sq>/dev/null||{ echo "Extract failed";umount -R /mnt;return; };echo "Installing bootloader...";mount --bind /dev /mnt/dev;mount --bind /proc /mnt/proc;mount --bind /sys /mnt/sys;chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Cybr $D>/dev/null 2>&1;chroot /mnt grub-install --target=i386-pc $D>/dev/null 2>&1;chroot /mnt update-grub>/dev/null 2>&1;sync;umount -R /mnt;echo;echo "Installation complete!";echo "Remove installation media and type: reboot"; }
          eth>/dev/null 2>&1&&echo "Auto-configured network"||true
          while :;do read -p "cybr> " c;case $c in wifi)wifi;;eth)eth;;install)inst;;shell)exec sh;;reboot)reboot -f;;*)echo "Commands: wifi | eth | install | shell | reboot";;esac;done
          EOF
          chmod +x i/init
          
          cd i && find .|cpio -oH newc|gzip -9>/tmp/initrd.gz && cd /tmp
          echo "Kernel: $(($(stat -c%s vmlinuz)/1024/1024))M | Initrd: $(($(stat -c%s initrd.gz)/1024))K"
          
          # Build ISO structure
          mkdir -p /w/iso/{boot/grub,EFI/BOOT,isolinux}
          
          # Copy bootloaders and kernel
          cp vmlinuz initrd.gz /w/iso/boot/
          cp ipxe-bios.lkrn /w/iso/boot/
          cp ipxe-uefi.efi /w/iso/EFI/BOOT/BOOTX64.EFI
          
          # ISOLINUX config (BIOS)
          cp /usr/lib/ISOLINUX/isolinux.bin /w/iso/isolinux/
          cp /usr/lib/syslinux/modules/bios/{ldlinux.c32,libcom32.c32,libutil.c32,menu.c32} /w/iso/isolinux/
          
          cat > /w/iso/isolinux/isolinux.cfg <<"ISOLINUX"
          DEFAULT menu.c32
          PROMPT 0
          TIMEOUT 100
          
          MENU TITLE Cybr Installer
          
          LABEL installer
            MENU LABEL Cybr Installer (Direct)
            KERNEL /boot/vmlinuz
            APPEND initrd=/boot/initrd.gz
          
          LABEL ipxe
            MENU LABEL Cybr Installer (iPXE)
            KERNEL /boot/ipxe-bios.lkrn
          
          LABEL shell
            MENU LABEL Boot to Shell
            KERNEL /boot/vmlinuz
            APPEND initrd=/boot/initrd.gz
          ISOLINUX
          
          # GRUB config (UEFI)
          cat > /w/iso/boot/grub/grub.cfg <<"GRUB"
          set timeout=10
          set default=0
          
          menuentry "Cybr Installer (Direct)" {
            linux /boot/vmlinuz
            initrd /boot/initrd.gz
          }
          
          menuentry "Cybr Installer (iPXE)" {
            chainloader /EFI/BOOT/BOOTX64.EFI
          }
          
          menuentry "Boot to Shell" {
            linux /boot/vmlinuz
            initrd /boot/initrd.gz
          }
          GRUB
          
          # Create UEFI boot image
          dd if=/dev/zero of=/tmp/efiboot.img bs=1M count=10
          mkfs.vfat /tmp/efiboot.img
          mmd -i /tmp/efiboot.img ::/EFI
          mmd -i /tmp/efiboot.img ::/EFI/BOOT
          mcopy -i /tmp/efiboot.img /w/iso/EFI/BOOT/BOOTX64.EFI ::/EFI/BOOT/
          
          # Build hybrid BIOS+UEFI ISO
          xorriso -as mkisofs \
            -o "/w/${ISO_NAME}.iso" \
            -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
            -c isolinux/boot.cat \
            -b isolinux/isolinux.bin \
            -no-emul-boot \
            -boot-load-size 4 \
            -boot-info-table \
            -eltorito-alt-boot \
            -e efiboot.img \
            -no-emul-boot \
            -isohybrid-gpt-basdat \
            -append_partition 2 0xef /tmp/efiboot.img \
            /w/iso/ 2>&1 | grep -E "ISO|sectors|Written"
          
          echo "ISO: $(($(stat -c%s /w/${ISO_NAME}.iso)/1024/1024))MB"
          '

      - name: Generate checksums
        run: |
          sha256sum "${{ steps.set-names.outputs.iso_name }}.iso" > "${{ steps.set-names.outputs.iso_name }}.iso.sha256"
          
          if [ "${{ inputs.build_type }}" != "iso-only" ] && [ -f "${{ steps.set-names.outputs.base_name }}.squashfs" ]; then
            sha256sum "${{ steps.set-names.outputs.base_name }}.squashfs" > "${{ steps.set-names.outputs.base_name }}.squashfs.sha256"
          fi
          
          echo "### Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type:** ${{ inputs.build_type || 'full' }}" >> $GITHUB_STEP_SUMMARY
          echo "**ISO:** ${{ steps.set-names.outputs.iso_name }}.iso ($(($(stat -c%s "${{ steps.set-names.outputs.iso_name }}.iso")/1024/1024))MB)" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.build_type }}" != "iso-only" ] && [ -f "${{ steps.set-names.outputs.base_name }}.squashfs" ]; then
            echo "**Base:** ${{ steps.set-names.outputs.base_name }}.squashfs ($(($(stat -c%s "${{ steps.set-names.outputs.base_name }}.squashfs")/1024/1024))MB)" >> $GITHUB_STEP_SUMMARY
          fi

      - uses: actions/upload-artifact@v4
        with:
          name: "cybr-build-${{ github.run_number }}"
          path: |
            ${{ steps.set-names.outputs.iso_name }}.iso
            ${{ steps.set-names.outputs.iso_name }}.iso.sha256
            ${{ steps.set-names.outputs.base_name }}.squashfs
            ${{ steps.set-names.outputs.base_name }}.squashfs.sha256
          retention-days: 7

  upload:
    runs-on: ubuntu-latest
    needs: build-base
    if: ${{ github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main' }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: "cybr-build-${{ github.run_number }}"

      - name: Upload to SourceForge
        env:
          SF_USER: ${{ secrets.SF_USER }}
          SF_PASS: ${{ secrets.SF_PASS }}
          ISO_NAME: ${{ needs.build-base.outputs.iso_name }}
          BASE_NAME: ${{ needs.build-base.outputs.base_name }}
          BUILD_TYPE: ${{ inputs.build_type }}
        run: |
          [ -z "$SF_USER" ] && exit 0
          sudo apt-get update && sudo apt-get install -y sshpass rsync
          
          # Upload ISO with retry logic
          for i in 1 2 3; do
            sshpass -p "$SF_PASS" rsync -avP -e "ssh -o StrictHostKeyChecking=no" "${ISO_NAME}.iso" "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/" && break
            [ $i -eq 3 ] && exit 1
            sleep 30
          done
          
          # Upload Base with retry logic (only if full build)
          if [ "$BUILD_TYPE" != "iso-only" ] && [ -f "${BASE_NAME}.squashfs" ]; then
            for i in 1 2 3; do
              sshpass -p "$SF_PASS" rsync -avP -e "ssh -o StrictHostKeyChecking=no" "${BASE_NAME}.squashfs" "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/base/" && break
              [ $i -eq 3 ] && exit 1
              sleep 30
            done
          fi