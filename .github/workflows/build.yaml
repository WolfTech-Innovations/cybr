name: "Cybr Build"

on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - iso-only
  push:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * 0'

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@v4

      - name: Free disk space
        if: ${{ inputs.build_type != 'iso-only' }}
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache
          sudo docker system prune -af --volumes

      - name: Build Cybr
        run: |
          docker run --rm --privileged -v "$PWD:/w" -e BUILD_TYPE="${{ inputs.build_type || 'full' }}" \
            -e RUN_NUM="${{ github.run_number }}" debian:bookworm bash -c '
          set -ex
          export DEBIAN_FRONTEND=noninteractive
          
          cat>/etc/apt/sources.list<<S
          deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware
          S
          
          apt-get update && apt-get install -y debootstrap squashfs-tools wget curl gnupg2 xorriso \
            dosfstools grub-efi-amd64-bin grub-pc-bin grub-common mtools git build-essential cpio \
            linux-image-amd64 firmware-linux wpasupplicant parted iw ethtool
          
          cd /w
          BASE="cybr-base-v${RUN_NUM}"
          ISO="cybr-netinstall-v${RUN_NUM}"
          
          if [ "$BUILD_TYPE" = "full" ]; then
            echo "=== Building Base ==="
            debootstrap --arch=amd64 --variant=minbase bookworm base http://deb.debian.org/debian/
            chroot base bash<<E
          cat>/etc/apt/sources.list<<S
          deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
          S
          apt-get update && apt-get install -y curl gnupg2 ca-certificates
          curl -fsSL https://liquorix.net/liquorix-keyring.gpg -o /usr/share/keyrings/liquorix.gpg
          cat>/etc/apt/sources.list.d/liquorix.sources<<L
          Types: deb
          URIs: https://liquorix.net/debian
          Suites: bookworm
          Components: main
          Signed-By: /usr/share/keyrings/liquorix.gpg
          L
          apt-get update && apt-get install -y linux-image-liquorix-amd64 firmware-linux systemd sudo \
            phosh-full gdm3 network-manager firefox-esr flatpak gparted ntfs-3g e2fsprogs nano \
            grub-efi-amd64 grub-pc-bin
          dpkg --add-architecture i386 && apt-get update
          apt-get install -y steam libgl1-mesa-dri:amd64 libgl1-mesa-dri:i386 mesa-vulkan-drivers:amd64 liblzma-dev \
            mesa-vulkan-drivers:i386
          wget -qO /tmp/d.deb "https://discord.com/api/download?platform=linux&format=deb"
          apt-get install -y /tmp/d.deb || apt-get install -f -y
          cat>/etc/os-release<<O
          NAME="Cybr"
          ID=cybr
          ID_LIKE=debian
          VERSION_ID="1.0"
          O
          useradd -m -s /bin/bash -G sudo,audio,video,netdev cybruser
          echo "cybruser:cybr"|chpasswd
          echo "root:root"|chpasswd
          echo -e "[daemon]\nAutomaticLoginEnable=true\nAutomaticLogin=cybruser">/etc/gdm3/custom.conf
          systemctl enable gdm3 NetworkManager
          apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/*
          E
            mksquashfs base "${BASE}.squashfs" -comp xz -b 1M
            echo "✓ Base: $(($(stat -c%s ${BASE}.squashfs)/1024/1024))MB"
          else
            echo "=== Skipping Base (ISO-only) ==="
          fi
          
          echo "=== Building ISO ==="
          cd /tmp
          cp "$(find /boot -name vmlinuz-* | tail -1)" vmlinuz
          KVER=$(ls /lib/modules/|tail -1)
          
          cd /tmp
          
          wget -qO bb https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox
          chmod +x bb
          mkdir -p i/{bin,sbin,proc,sys,dev,mnt,etc,lib/{firmware,modules,x86_64-linux-gnu},lib64}
          cp bb i/bin/busybox
          cd i/bin
          for c in sh mount umount cat wget ping ip ls modprobe; do ln -s busybox $c; done
          cd ../sbin
          for c in init mdev udhcpc; do ln -s ../bin/busybox $c; done
          cd /tmp
          cp -r /lib/firmware/* i/lib/firmware/
          mkdir -p i/lib/modules/$KVER
          for d in drivers/net drivers/virtio kernel/net; do
            find /lib/modules/$KVER/$d -name "*.ko" 2>/dev/null|while read m; do
              r="${m#/lib/modules/$KVER/}"
              mkdir -p "i/lib/modules/$KVER/$(dirname $r)"
              cp "$m" "i/lib/modules/$KVER/$r"
            done
          done
          cp /lib/modules/$KVER/modules.* i/lib/modules/$KVER/ 2>/dev/null||true
          for t in /usr/sbin/unsquashfs /sbin/{parted,wpa_supplicant,iw,ethtool}; do
            if [ -f "$t" ]; then
              cp "$t" i/sbin/
              ldd "$t" 2>/dev/null | grep -oP '/[^ ]+' | while read l; do
                [ -f "$l" ] && mkdir -p "i$(dirname $l)" && cp "$l" "i$l" 2>/dev/null
              done
            fi
          done
          
          # Copy essential system libraries
          cp /lib64/ld-linux-x86-64.so.2 i/lib64/ 2>/dev/null || true
          
          # Copy all required libraries to the proper location
          for l in libc.so.6 libm.so.6 libpthread.so.0 libdl.so.2 librt.so.1 \
                   libnl-*.so.* libdbus-1.so.* libblkid.so.* libuuid.so.* \
                   libz.so.* liblzma.so.* libresolv.so.* libnss_*.so.* \
                   libcrypto.so.* libssl.so.* libgcc_s.so.*; do
            find /lib /usr/lib /lib64 -name "$l" 2>/dev/null | while read f; do
              [ -f "$f" ] && mkdir -p "i$(dirname $f)" && cp "$f" "i$f" 2>/dev/null
            done
          done
          echo "nameserver 8.8.8.8">i/etc/resolv.conf
          
          cat>i/init<<'INITEOF'
#!/bin/sh
# This runs as PID 1 - must never exit or kernel panics

# Trap to prevent exit
trap "" EXIT

# Basic error handling - don't exit, just report
set +e

export PATH=/bin:/sbin:/usr/bin:/usr/sbin
export LD_LIBRARY_PATH=/lib:/lib64:/lib/x86_64-linux-gnu:/usr/lib:/usr/lib/x86_64-linux-gnu

echo "Starting Cybr installer (PID: $$)..."

# Mount core filesystems
mount -t proc none /proc 2>/dev/null || echo "proc mount failed"
mount -t sysfs none /sys 2>/dev/null || echo "sys mount failed"
mount -t devtmpfs none /dev 2>/dev/null || echo "dev mount failed"
mkdir -p /dev/pts /dev/shm /tmp /run
mount -t devpts none /dev/pts 2>/dev/null
mount -t tmpfs none /dev/shm 2>/dev/null
mount -t tmpfs none /tmp 2>/dev/null
mount -t tmpfs none /run 2>/dev/null

# Populate /dev
/sbin/mdev -s 2>/dev/null

hostname cybr 2>/dev/null || true

echo "Loading network modules..."
for m in e1000 e1000e r8169 virtio_net; do
  modprobe $m 2>/dev/null && echo "  $m: OK" || true
done

sleep 2

echo "Bringing up network interfaces..."
for n in /sys/class/net/*; do
  n=$(basename "$n")
  [ "$n" = "lo" ] && continue
  ip link set "$n" up 2>/dev/null && echo "  $n: up" || true
done

clear
cat<<MENU
╔══════════════════╗
║ CYBR INSTALLER   ║
╠══════════════════╣
║ 1) WiFi          ║
║ 2) Ethernet      ║
║ 3) Install       ║
║ 4) Shell         ║
╚══════════════════╝
MENU

do_eth() {
  E=$(ip -br l 2>/dev/null|grep "^e"|head -1|awk '{print $1}')
  if [ -z "$E" ]; then
    echo "No ethernet adapter found"
    return 1
  fi
  echo "Using $E..."
  ip link set "$E" up 2>/dev/null
  udhcpc -i "$E" -qn 2>&1|tail -2
  if ping -c1 -W2 8.8.8.8 >/dev/null 2>&1; then
    echo "✓ Connected"
    return 0
  else
    echo "✗ Connection failed"
    return 1
  fi
}

do_wifi() {
  W=$(ip -br l 2>/dev/null|grep "^wl"|head -1|awk '{print $1}')
  if [ -z "$W" ]; then
    echo "No WiFi adapter found"
    return 1
  fi
  printf "SSID: "; read -r S
  printf "Password: "; read -rs P; echo
  cat>/tmp/wpa.conf<<WPA
network={
  ssid="$S"
  psk="$P"
}
WPA
  killall wpa_supplicant 2>/dev/null
  wpa_supplicant -B -i "$W" -c /tmp/wpa.conf 2>/dev/null
  sleep 4
  udhcpc -i "$W" -qn 2>&1|tail -2
  if ping -c1 -W2 8.8.8.8 >/dev/null 2>&1; then
    echo "✓ Connected"
    return 0
  else
    echo "✗ Connection failed"
    return 1
  fi
}

do_install() {
  if ! ping -c1 -W2 8.8.8.8 >/dev/null 2>&1; then
    echo "No internet connection - try option 1 or 2 first"
    return 1
  fi
  
  lsblk -d -o NAME,SIZE,TYPE 2>/dev/null | grep disk
  printf "Target disk (e.g. sda): "; read -r D
  D="/dev/$D"
  
  if [ ! -b "$D" ]; then
    echo "Invalid disk: $D"
    return 1
  fi
  
  printf "ERASE ALL DATA on $D? Type YES: "; read -r C
  if [ "$C" != "YES" ]; then
    echo "Cancelled"
    return 0
  fi
  
  echo "Partitioning $D..."
  parted -s "$D" mklabel gpt \
    mkpart ESP fat32 1MiB 513MiB \
    mkpart primary ext4 513MiB 100% \
    set 1 esp on 2>&1 | tail -3
  
  if [ $? -ne 0 ]; then
    echo "Partitioning failed"
    return 1
  fi
  
  sleep 2
  echo "Formatting partitions..."
  mkfs.vfat -F32 "${D}1" >/dev/null 2>&1
  mkfs.ext4 -F "${D}2" >/dev/null 2>&1
  
  echo "Mounting..."
  mount "${D}2" /mnt 2>/dev/null
  if [ $? -ne 0 ]; then
    echo "Failed to mount root partition"
    return 1
  fi
  
  mkdir -p /mnt/boot/efi
  mount "${D}1" /mnt/boot/efi 2>/dev/null
  if [ $? -ne 0 ]; then
    echo "Failed to mount EFI partition"
    umount /mnt 2>/dev/null
    return 1
  fi
  
  echo "Downloading base system..."
  U="https://sourceforge.net/projects/wolfos/files/gaming/base"
  L=$(wget -qO- "$U" 2>/dev/null|grep -oP "cybr-base-v[0-9]+"|sort -V|tail -1)
  
  if [ -z "$L" ]; then
    echo "Could not find base system online"
    umount -R /mnt 2>/dev/null
    return 1
  fi
  
  echo "Found: $L"
  echo "Downloading (this may take a while)..."
  
  wget -O /tmp/base.squashfs "$U/$L.squashfs/download" 2>&1 | grep -E "saved|failed"
  
  if [ ! -f /tmp/base.squashfs ]; then
    echo "Download failed"
    umount -R /mnt 2>/dev/null
    return 1
  fi
  
  echo "Extracting base system (this takes several minutes)..."
  unsquashfs -f -d /mnt /tmp/base.squashfs 2>&1 | grep -E "created|failed"
  
  if [ $? -ne 0 ]; then
    echo "Extraction failed"
    umount -R /mnt 2>/dev/null
    return 1
  fi
  
  echo "Installing bootloader..."
  mount --bind /dev /mnt/dev 2>/dev/null
  mount --bind /proc /mnt/proc 2>/dev/null
  mount --bind /sys /mnt/sys 2>/dev/null
  
  chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Cybr "$D" 2>&1|tail -3
  chroot /mnt grub-install --target=i386-pc "$D" 2>&1|tail -3
  chroot /mnt update-grub 2>&1|tail -3
  
  sync
  umount -R /mnt 2>/dev/null
  
  echo ""
  echo "════════════════════════════════════"
  echo "✓ Installation complete!"
  echo "════════════════════════════════════"
  echo "Remove installation media and type: reboot"
  echo ""
  
  return 0
}

# Try ethernet on startup
echo "Attempting automatic ethernet connection..."
do_eth >/dev/null 2>&1 && echo "Auto-connected via ethernet" || true

# Main loop - MUST NEVER EXIT (we are PID 1)
while true; do
  printf "\ncybr> "
  read -r cmd || { sleep 1; continue; }
  
  case "$cmd" in
    1|wifi)
      do_wifi || true
      ;;
    2|eth|ethernet)
      do_eth || true
      ;;
    3|install)
      do_install || true
      ;;
    4|shell)
      echo "Type 'exit' to return to menu"
      /bin/sh || true
      ;;
    reboot)
      echo "Rebooting..."
      sync
      sleep 1
      reboot -f
      # If reboot fails, loop continues
      ;;
    poweroff|halt|shutdown)
      echo "Powering off..."
      sync
      sleep 1
      poweroff -f
      # If poweroff fails, loop continues
      ;;
    help|h|\?)
      cat<<HELP

Available commands:
  1, wifi      - Configure WiFi connection
  2, eth       - Configure Ethernet connection
  3, install   - Install Cybr to disk
  4, shell     - Drop to shell (type 'exit' to return)
  reboot       - Reboot system
  poweroff     - Power off system
  help         - Show this help

HELP
      ;;
    "")
      # Empty input, just continue
      ;;
    *)
      echo "Unknown command. Type 'help' for available commands."
      ;;
  esac
done

# This line should never be reached, but just in case:
exec /bin/sh
INITEOF
          chmod +x i/init
          cd i
          find . | cpio -oH newc | gzip -9 > /tmp/initrd.gz
          cd /tmp
          
          # Clean up any existing iso directory/file
          rm -rf iso
          
          # Create fresh ISO directory structure
          mkdir -p iso/boot/grub
          
          # Copy kernel and initrd
          cp vmlinuz initrd.gz iso/boot/
          
          # Create GRUB configuration
          cat>iso/boot/grub/grub.cfg<<G
          set timeout=5
          menuentry "Install Cybr" {
            linux /boot/vmlinuz
            initrd /boot/initrd.gz
          }
          G
          
          # For BIOS: Copy GRUB modules to ISO
          mkdir -p iso/boot/grub/i386-pc
          cp /usr/lib/grub/i386-pc/*.mod iso/boot/grub/i386-pc/ 2>/dev/null || true
          cp /usr/lib/grub/i386-pc/*.lst iso/boot/grub/i386-pc/ 2>/dev/null || true
          
          # Create BIOS boot image using cdboot.img and core.img
          cat /usr/lib/grub/i386-pc/cdboot.img > iso/boot/grub/bios.img
          grub-mkimage \
            -d /usr/lib/grub/i386-pc \
            -O i386-pc \
            -o core.img \
            -p /boot/grub \
            biosdisk iso9660
          cat core.img >> iso/boot/grub/bios.img
          rm core.img
          
          # Create GRUB EFI bootloader
          mkdir -p iso/EFI/BOOT
          grub-mkstandalone \
            -d /usr/lib/grub/x86_64-efi \
            -O x86_64-efi \
            --modules="part_gpt part_msdos iso9660" \
            --locales="" \
            --fonts="" \
            -o iso/EFI/BOOT/BOOTX64.EFI \
            "boot/grub/grub.cfg=iso/boot/grub/grub.cfg"
          
          # Create EFI boot image
          dd if=/dev/zero of=iso/efi.img bs=1M count=10 2>/dev/null
          mkfs.vfat iso/efi.img >/dev/null 2>&1
          mmd -i iso/efi.img ::/EFI ::/EFI/BOOT
          mcopy -i iso/efi.img iso/EFI/BOOT/BOOTX64.EFI ::/EFI/BOOT/
          
          # Create hybrid ISO with both BIOS and UEFI support
          xorriso -as mkisofs -o "/w/${ISO}.iso" \
            -r -J -joliet-long \
            -b boot/grub/bios.img \
            -no-emul-boot \
            -boot-load-size 4 \
            -boot-info-table \
            --grub2-boot-info \
            --grub2-mbr /usr/lib/grub/i386-pc/boot_hybrid.img \
            -eltorito-alt-boot \
            -e efi.img \
            -no-emul-boot \
            -isohybrid-gpt-basdat \
            iso/ 2>&1 | tail -3
          
          # Generate checksums
          cd /w
          sha256sum "${ISO}.iso" > "${ISO}.iso.sha256"
          if [ -f "${BASE}.squashfs" ]; then
            sha256sum "${BASE}.squashfs" > "${BASE}.squashfs.sha256"
          fi
          
          echo "=== Complete ==="
          ls -lh *.iso *.squashfs 2>/dev/null || true
          '

      - uses: actions/upload-artifact@v4
        with:
          name: "cybr-build-${{ github.run_number }}"
          path: |
            *.iso
            *.iso.sha256
            *.squashfs
            *.squashfs.sha256
          retention-days: 7

  upload:
    runs-on: ubuntu-latest
    needs: build
    if: ${{ github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main' }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: "cybr-build-${{ github.run_number }}"

      - name: Upload to SourceForge
        env:
          SF_USER: ${{ secrets.SF_USER }}
          SF_PASS: ${{ secrets.SF_PASS }}
        run: |
          [ -z "$SF_USER" ] && exit 0
          sudo apt-get update && sudo apt-get install -y sshpass rsync
          for f in *.iso; do
            for i in 1 2 3; do
              sshpass -p "$SF_PASS" rsync -avP -e "ssh -o StrictHostKeyChecking=no" \
                "$f" "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/" && break
              sleep 30
            done
          done
          for f in *.squashfs; do
            [ -f "$f" ] || continue
            for i in 1 2 3; do
              sshpass -p "$SF_PASS" rsync -avP -e "ssh -o StrictHostKeyChecking=no" \
                "$f" "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/base/" && break
              sleep 30
            done
          done