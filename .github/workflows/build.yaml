name: "Cybr Build"

on:
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - iso-only
      skip_base:
        description: 'Skip base system build (faster ISO-only builds)'
        required: false
        default: false
        type: boolean
  push:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * 0'

jobs:
  build-base:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    outputs:
      base_name: ${{ steps.set-names.outputs.base_name }}
      iso_name: ${{ steps.set-names.outputs.iso_name }}

    steps:
      - uses: actions/checkout@v4

      - name: Set build names
        id: set-names
        run: |
          echo "base_name=cybr-base-v${{ github.run_number }}" >> $GITHUB_OUTPUT
          echo "iso_name=cybr-netinstall-v${{ github.run_number }}" >> $GITHUB_OUTPUT

      - name: Free disk space
        if: ${{ inputs.build_type != 'iso-only' && !inputs.skip_base }}
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/boost /opt/hostedtoolcache
          sudo docker system prune -af --volumes
          sudo apt-get autoremove -y && sudo apt-get clean

      - name: Build Cybr Base System
        if: ${{ inputs.build_type != 'iso-only' && !inputs.skip_base }}
        run: |
          BASE_NAME="${{ steps.set-names.outputs.base_name }}"
          docker run --rm --privileged -v "$PWD:/w" -e BASE_NAME="${BASE_NAME}" debian:bookworm bash -c '
          set -e
          export DEBIAN_FRONTEND=noninteractive
          apt-get update && apt-get install -y debootstrap squashfs-tools wget curl gnupg2
          
          debootstrap --arch=amd64 --variant=minbase bookworm base http://deb.debian.org/debian/
          
          chroot base bash <<'"'"'EOF'"'"'
          export DEBIAN_FRONTEND=noninteractive
          
          cat > /etc/apt/sources.list <<SOURCES
          deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware
          SOURCES
          
          apt-get update && apt-get install -y curl gnupg2 ca-certificates
          
          mkdir -p /usr/share/keyrings
          curl -fsSL https://liquorix.net/liquorix-keyring.gpg -o /usr/share/keyrings/liquorix-archive-keyring.gpg
          cat > /etc/apt/sources.list.d/liquorix.sources <<LIQUORIX
          Types: deb
          URIs: https://liquorix.net/debian
          Suites: bookworm
          Components: main
          Architectures: amd64
          Signed-By: /usr/share/keyrings/liquorix-archive-keyring.gpg
          LIQUORIX
          
          apt-get update
          apt-get install -y linux-image-liquorix-amd64 firmware-linux-free firmware-linux-nonfree systemd sudo phosh-full gdm3 network-manager firefox-esr flatpak gparted ntfs-3g dosfstools e2fsprogs nano
          
          dpkg --add-architecture i386 && apt-get update
          apt-get install -y steam libgl1-mesa-dri:amd64 libgl1-mesa-dri:i386 mesa-vulkan-drivers:amd64 mesa-vulkan-drivers:i386
          
          wget -O /tmp/discord.deb "https://discord.com/api/download?platform=linux&format=deb"
          apt-get install -y /tmp/discord.deb || apt-get install -f -y
          
          cat > /etc/os-release <<OSREL
          NAME="Cybr"
          PRETTY_NAME="Cybr Mobile Gaming Edition"
          ID=cybr
          ID_LIKE=debian
          VERSION_ID="1.0"
          HOME_URL="https://getcybr.org/"
          OSREL
          
          useradd -m -s /bin/bash -G sudo,audio,video,netdev cybruser
          echo "cybruser:cybr" | chpasswd
          echo "root:root" | chpasswd
          
          mkdir -p /etc/gdm3
          echo -e "[daemon]\nAutomaticLoginEnable=true\nAutomaticLogin=cybruser" > /etc/gdm3/custom.conf
          
          systemctl enable gdm3 NetworkManager
          apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
          EOF
          
          mksquashfs base "${BASE_NAME}.squashfs" -comp xz -b 1M -Xdict-size 100%
          mv "${BASE_NAME}.squashfs" /w/
          '

      - name: Build Minimal Installer ISO
        run: |
          ISO_NAME="${{ steps.set-names.outputs.iso_name }}"
          docker run --rm --privileged -v "$PWD:/w" -e ISO_NAME="${ISO_NAME}" debian:bookworm bash -c '
          set -e
          export DEBIAN_FRONTEND=noninteractive
          apt-get update && apt-get install -y wget cpio xorriso isolinux syslinux-utils squashfs-tools dosfstools
          
          cd /tmp
          
          # Enable non-free firmware repo
          echo "deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware" > /etc/apt/sources.list
          apt-get update
          
          # Install everything we need
          apt-get install -y linux-image-amd64 firmware-iwlwifi wpasupplicant parted squashfs-tools iw
          
          # Get kernel
          cp /boot/vmlinuz-* /tmp/vmlinuz
          
          # Get busybox
          wget -O busybox https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox
          chmod +x busybox
          
          # Create initramfs
          mkdir -p initramfs/{bin,sbin,proc,sys,dev,mnt,lib/firmware,lib/x86_64-linux-gnu,lib64}
          cp busybox initramfs/bin/
          
          cd initramfs/bin
          for cmd in sh ls cp mv rm mkdir mount umount cat echo wget tar gzip cpio dd chmod ln ps sleep ping ip grep head sort tail cut awk sed find; do ln -s busybox $cmd; done
          cd ../sbin
          for cmd in init poweroff reboot mdev blkid mkfs.ext4 mkfs.vfat udhcpc; do ln -s ../bin/busybox $cmd; done
          cd /tmp
          
          # Copy firmware
          cp -r /lib/firmware/* initramfs/lib/firmware/
          
          # Copy tools
          cp /sbin/wpa_supplicant initramfs/sbin/
          cp /sbin/parted initramfs/sbin/
          cp /sbin/iw initramfs/sbin/
          cp $(which unsquashfs) initramfs/sbin/ || cp /usr/bin/unsquashfs initramfs/sbin/
          
          # Copy libs - comprehensive list for networking
          cp /lib64/ld-linux-x86-64.so.2 initramfs/lib64/
          
          # Copy all required libraries
          for lib in libc.so.6 libnl-3.so.200 libnl-genl-3.so.200 libblkid.so.1 libuuid.so.1 \
                     libdbus-1.so.3 libpthread.so.0 librt.so.1 libdl.so.2 libm.so.6 \
                     libnl-route-3.so.200 libpcre.so.3 liblzma.so.5 libz.so.1 libzstd.so.1 \
                     libresolv.so.2 libnss_dns.so.2 libnss_files.so.2; do
            find /lib /usr/lib -name "$lib" -exec cp {} initramfs/lib/x86_64-linux-gnu/ \; 2>/dev/null || true
          done
          
          # Copy SSL certificates for HTTPS
          mkdir -p initramfs/etc/ssl/certs
          cp -r /etc/ssl/certs/* initramfs/etc/ssl/certs/ 2>/dev/null || true
          
          cat > initramfs/init <<'"'"'INIT'"'"'
          #!/bin/sh
          export PATH=/bin:/sbin LD_LIBRARY_PATH=/lib/x86_64-linux-gnu:/lib64
          mount -t proc none /proc; mount -t sysfs none /sys; mount -t devtmpfs none /dev; mdev -s
          
          # Network setup
          hostname cybr-installer
          
          clear
          echo "=== Cybr Installer ==="
          echo "Commands: wifi, ethernet, install, shell"
          
          ethernet_setup() {
            ETH=$(ip link | grep -o "e[^:]*" | grep -E "^(eth|enp)" | head -1)
            [ -z "$ETH" ] && echo "No ethernet adapter found" && return 1
            echo "Found: $ETH"
            ip link set "$ETH" up
            echo "Getting IP via DHCP..."
            udhcpc -i "$ETH" -q
            sleep 2
            if ping -c 1 -W 3 8.8.8.8 > /dev/null 2>&1; then
              echo "Ethernet connected!"
              ip addr show "$ETH"
            else
              echo "Failed to connect"
              return 1
            fi
          }
          
          wifi_setup() {
            WLAN=$(ip link | grep -o "wl[^:]*" | head -1)
            [ -z "$WLAN" ] && echo "No WiFi adapter found" && return 1
            echo "Found: $WLAN"
            ip link set "$WLAN" up
            sleep 2
            
            echo "Scanning networks..."
            iw dev "$WLAN" scan | grep SSID | head -10
            
            read -p "SSID: " SSID
            read -sp "Password: " PASS
            echo
            
            cat > /tmp/wpa.conf <<WPA
          ctrl_interface=/var/run/wpa_supplicant
          network={
            ssid="$SSID"
            psk="$PASS"
          }
          WPA
            
            mkdir -p /var/run/wpa_supplicant
            wpa_supplicant -B -i "$WLAN" -c /tmp/wpa.conf
            sleep 5
            
            echo "Getting IP via DHCP..."
            udhcpc -i "$WLAN" -q
            sleep 2
            
            if ping -c 1 -W 3 8.8.8.8 > /dev/null 2>&1; then
              echo "WiFi connected!"
              ip addr show "$WLAN"
            else
              echo "Failed to connect"
              return 1
            fi
          }
          
          install_cybr() {
            if ! ping -c 1 -W 3 8.8.8.8 > /dev/null 2>&1; then
              echo "No internet connection!"
              echo "Try: wifi or ethernet"
              return 1
            fi
            
            echo "Available disks:"
            blkid | grep -v loop
            lsblk -d -o NAME,SIZE,TYPE | grep disk
            
            read -p "Disk to install to (e.g. sda): " D
            D="/dev/$D"
            
            [ ! -b "$D" ] && echo "Device $D not found" && return 1
            
            echo "WARNING: This will erase ALL data on $D"
            read -p "Type YES to continue: " C
            [ "$C" != "YES" ] && echo "Cancelled" && return 1
            
            echo "Partitioning $D..."
            parted -s "$D" mklabel gpt mkpart ESP fat32 1MiB 513MiB mkpart primary ext4 513MiB 100%
            parted -s "$D" set 1 esp on
            sleep 2
            
            echo "Formatting partitions..."
            mkfs.vfat -F32 "${D}1"
            mkfs.ext4 -F "${D}2"
            
            echo "Mounting..."
            mount "${D}2" /mnt
            mkdir -p /mnt/boot/efi
            mount "${D}1" /mnt/boot/efi
            
            echo "Downloading base system..."
            BASE_URL="https://sourceforge.net/projects/wolfos/files/gaming/base"
            
            echo "Finding latest version..."
            LATEST=$(wget -qO- "$BASE_URL/" | grep -oP "cybr-base-v\d+" | sort -V | tail -1)
            
            if [ -z "$LATEST" ]; then
              echo "ERROR: Could not find latest version"
              umount -R /mnt
              return 1
            fi
            
            echo "Latest version: $LATEST"
            echo "Downloading (this may take a while)..."
            
            if ! wget --progress=bar:force -O /tmp/base.sq "${BASE_URL}/${LATEST}.squashfs/download"; then
              echo "ERROR: Download failed"
              umount -R /mnt
              return 1
            fi
            
            echo "Extracting system (this will take a few minutes)..."
            unsquashfs -f -d /mnt /tmp/base.sq
            
            echo "Installing bootloader..."
            mount --bind /dev /mnt/dev
            mount --bind /proc /mnt/proc
            mount --bind /sys /mnt/sys
            
            chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Cybr "$D"
            chroot /mnt update-grub
            
            umount /mnt/dev /mnt/proc /mnt/sys
            sync
            umount -R /mnt
            
            echo ""
            echo "=== Installation Complete ==="
            echo "You can now reboot and remove the installation media"
            echo "Type 'reboot' to restart"
          }
          
          # Auto-detect and setup ethernet if available
          echo "Checking for ethernet..."
          if ethernet_setup > /dev/null 2>&1; then
            echo "Ethernet connected automatically"
          fi
          
          while true; do
            read -p "cybr> " cmd
            case "$cmd" in
              wifi) wifi_setup;;
              ethernet) ethernet_setup;;
              install) install_cybr;;
              shell) exec /bin/sh;;
              reboot) sync; reboot -f;;
              *) echo "Commands: wifi, ethernet, install, shell, reboot";;
            esac
          done
          INIT
          chmod +x initramfs/init
          
          cd initramfs
          find . | cpio -o -H newc | gzip -9 > /tmp/initrd.gz
          
          # Build ISO with ISOLINUX (BIOS) and GRUB (EFI)
          mkdir -p /w/iso/{boot,isolinux,EFI/BOOT}
          cp /tmp/vmlinuz /tmp/initrd.gz /w/iso/boot/
          
          # ISOLINUX for BIOS boot
          cat > /w/iso/isolinux/isolinux.cfg <<CFG
          DEFAULT linux
          LABEL linux
            KERNEL /boot/vmlinuz
            APPEND initrd=/boot/initrd.gz quiet
          CFG
          
          # Copy ISOLINUX binaries and required modules
          cp /usr/lib/ISOLINUX/isolinux.bin /w/iso/isolinux/
          cp /usr/lib/syslinux/modules/bios/ldlinux.c32 /w/iso/isolinux/
          cp /usr/lib/syslinux/modules/bios/libcom32.c32 /w/iso/isolinux/
          cp /usr/lib/syslinux/modules/bios/libutil.c32 /w/iso/isolinux/
          
          # GRUB for EFI boot
          apt-get install -y grub-efi-amd64-bin mtools
          
          cat > /w/iso/EFI/BOOT/grub.cfg <<GRUBCFG
          set timeout=5
          set default=0
          
          menuentry "Cybr Installer" {
            linux /boot/vmlinuz quiet
            initrd /boot/initrd.gz
          }
          GRUBCFG
          
          # Create EFI boot image
          grub-mkstandalone \
            --format=x86_64-efi \
            --output=/w/iso/EFI/BOOT/BOOTX64.EFI \
            --locales="" \
            --fonts="" \
            "boot/grub/grub.cfg=/w/iso/EFI/BOOT/grub.cfg"
          
          # Create El Torito EFI boot image
          dd if=/dev/zero of=/w/efiboot.img bs=1M count=10
          mkfs.vfat /w/efiboot.img
          mmd -i /w/efiboot.img ::/EFI
          mmd -i /w/efiboot.img ::/EFI/BOOT
          mcopy -i /w/efiboot.img /w/iso/EFI/BOOT/BOOTX64.EFI ::/EFI/BOOT/
          
          # Build hybrid ISO with both BIOS and EFI support
          xorriso -as mkisofs \
            -o "/w/${ISO_NAME}.iso" \
            -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
            -c isolinux/boot.cat \
            -b isolinux/isolinux.bin \
            -no-emul-boot -boot-load-size 4 -boot-info-table \
            -eltorito-alt-boot \
            -e --interval:appended_partition_2:all:: \
            -no-emul-boot \
            -isohybrid-gpt-basdat \
            -append_partition 2 C12A7328-F81F-11D2-BA4B-00A0C93EC93B /w/efiboot.img \
            /w/iso/
          '

      - name: Generate checksums
        run: |
          sha256sum "${{ steps.set-names.outputs.iso_name }}.iso" > "${{ steps.set-names.outputs.iso_name }}.iso.sha256"
          
          if [ "${{ inputs.build_type }}" != "iso-only" ]; then
            sha256sum "${{ steps.set-names.outputs.base_name }}.squashfs" > "${{ steps.set-names.outputs.base_name }}.squashfs.sha256"
          fi
          
          echo "### Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Build Type:** ${{ inputs.build_type || 'full' }}" >> $GITHUB_STEP_SUMMARY
          echo "**ISO:** ${{ steps.set-names.outputs.iso_name }}.iso ($(($(stat -c%s "${{ steps.set-names.outputs.iso_name }}.iso")/1024/1024))MB)" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.build_type }}" != "iso-only" ]; then
            echo "**Base:** ${{ steps.set-names.outputs.base_name }}.squashfs ($(($(stat -c%s "${{ steps.set-names.outputs.base_name }}.squashfs")/1024/1024))MB)" >> $GITHUB_STEP_SUMMARY
          fi

      - uses: actions/upload-artifact@v4
        with:
          name: "cybr-build-${{ github.run_number }}"
          path: |
            ${{ steps.set-names.outputs.iso_name }}.iso
            ${{ steps.set-names.outputs.iso_name }}.iso.sha256
            ${{ inputs.build_type != 'iso-only' && format('{0}.squashfs', steps.set-names.outputs.base_name) || '' }}
            ${{ inputs.build_type != 'iso-only' && format('{0}.squashfs.sha256', steps.set-names.outputs.base_name) || '' }}
          retention-days: 7

  upload:
    runs-on: ubuntu-latest
    needs: build-base
    if: ${{ github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main' }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: "cybr-build-${{ github.run_number }}"

      - name: Upload to SourceForge
        env:
          SF_USER: ${{ secrets.SF_USER }}
          SF_PASS: ${{ secrets.SF_PASS }}
          ISO_NAME: ${{ needs.build-base.outputs.iso_name }}
          BASE_NAME: ${{ needs.build-base.outputs.base_name }}
          BUILD_TYPE: ${{ inputs.build_type }}
        run: |
          [ -z "$SF_USER" ] && exit 0
          sudo apt-get update && sudo apt-get install -y sshpass rsync
          
          # Upload ISO with retry logic
          for i in 1 2 3; do
            sshpass -p "$SF_PASS" rsync -avP -e "ssh -o StrictHostKeyChecking=no" "${ISO_NAME}.iso" "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/" && break
            [ $i -eq 3 ] && exit 1
            sleep 30
          done
          
          # Upload Base with retry logic (only if full build)
          if [ "$BUILD_TYPE" != "iso-only" ]; then
            for i in 1 2 3; do
              sshpass -p "$SF_PASS" rsync -avP -e "ssh -o StrictHostKeyChecking=no" "${BASE_NAME}.squashfs" "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/base/" && break
              [ $i -eq 3 ] && exit 1
              sleep 30
            done
          fi