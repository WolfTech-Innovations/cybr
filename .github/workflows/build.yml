name: "Cybr K9 Build"

on:
  workflow_dispatch:
  push:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * 0'

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free disk space
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache
          sudo docker system prune -af --volumes

      - name: Create build script
        run: |
          cat > build.sh << 'BUILD_SCRIPT_EOF'
          #!/bin/bash
          set -ex
          export DEBIAN_FRONTEND=noninteractive
          
          # Configure APT sources
          cat > /etc/apt/sources.list << 'APT_SOURCES'
          deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware
          APT_SOURCES
          
          # Install build dependencies
          apt-get update && apt-get install -y \
            debootstrap squashfs-tools wget curl gnupg2 xorriso \
            dosfstools grub-efi-amd64-bin grub-pc-bin grub-common mtools \
            git build-essential cpio linux-image-amd64 firmware-linux \
            wpasupplicant parted iw ethtool
          
          cd /w
          ISO="cybr-k9-v${RUN_NUM}"
          
          echo "=== Building Root Filesystem ==="
          debootstrap --arch=amd64 --variant=minbase bookworm rootfs \
            http://deb.debian.org/debian/
          
          # Configure system
          cat > rootfs/etc/apt/sources.list << 'BASE_APT'
          deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware
          deb http://deb.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
          BASE_APT
          
          # Mount necessary filesystems for chroot
          mount --bind /dev rootfs/dev
          mount --bind /proc rootfs/proc
          mount --bind /sys rootfs/sys
          
          chroot rootfs /bin/bash << 'CHROOT_COMMANDS'
          export DEBIAN_FRONTEND=noninteractive
          
          # Update and install base packages
          apt-get update && apt-get install -y \
            linux-image-amd64 firmware-linux systemd sudo \
            network-manager wpasupplicant iw ethtool \
            xorg xserver-xorg xinit \
            libx11-dev libxrender-dev libxext-dev libxrandr-dev \
            libxft-dev libxcomposite-dev libxdamage-dev libxfixes-dev \
            git build-essential make gcc pkg-config \
            ntfs-3g e2fsprogs parted gparted \
            nano vim grub-efi-amd64 grub-pc-bin \
            console-setup keyboard-configuration locales \
            ca-certificates curl wget
          
          # Configure locale
          echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
          locale-gen
          
          # Clone and build K9 Desktop Environment
          cd /opt
          git clone https://github.com/WolfTech-Innovations/K9.git
          cd K9/src
          
          # Build K9
          bash build.bash
          
          # Install K9 system-wide
          mkdir -p /usr/local/bin /usr/share/xsessions
          cp ../k9 /usr/local/bin/
          chmod +x /usr/local/bin/k9
          
          # Create K9 desktop session file
          cat > /usr/share/xsessions/k9.desktop << 'K9_DESKTOP'
          [Desktop Entry]
          Name=K9 Desktop
          Comment=Lightweight X11 Desktop Environment
          Exec=/usr/local/bin/k9
          Type=Application
          DesktopNames=K9
          K9_DESKTOP
          
          # Create default user
          useradd -m -s /bin/bash -G sudo,audio,video,netdev k9user
          echo "k9user:k9" | chpasswd
          echo "root:root" | chpasswd
          
          # Configure auto-login and auto-start X with K9
          mkdir -p /etc/systemd/system/getty@tty1.service.d
          cat > /etc/systemd/system/getty@tty1.service.d/autologin.conf << 'AUTOLOGIN'
          [Service]
          ExecStart=
          ExecStart=-/sbin/agetty --autologin k9user --noclear %I \$TERM
          AUTOLOGIN
          
          # Auto-start X with K9 on login
          cat > /home/k9user/.bash_profile << 'BASH_PROFILE'
          if [ -z "$DISPLAY" ] && [ "$XDG_VTNR" = "1" ]; then
            exec startx
          fi
          BASH_PROFILE
          
          # Create .xinitrc to start K9
          cat > /home/k9user/.xinitrc << 'XINITRC'
          #!/bin/sh
          exec /usr/local/bin/k9
          XINITRC
          
          chmod +x /home/k9user/.xinitrc
          chown k9user:k9user /home/k9user/.bash_profile /home/k9user/.xinitrc
          
          # Create OS release info
          cat > /etc/os-release << 'OS_RELEASE'
          NAME="Cybr K9"
          ID=cybr-k9
          ID_LIKE=debian
          VERSION_ID="1.0"
          PRETTY_NAME="Cybr K9 Desktop"
          OS_RELEASE
          
          # Enable NetworkManager
          systemctl enable NetworkManager
          
          # Cleanup
          apt-get clean
          rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
          CHROOT_COMMANDS
          
          # Unmount chroot filesystems
          umount rootfs/dev rootfs/proc rootfs/sys
          
          # Create squashfs from rootfs
          echo "=== Creating SquashFS ==="
          mksquashfs rootfs filesystem.squashfs -comp xz -b 1M
          echo "✓ Filesystem created: $(($(stat -c%s filesystem.squashfs)/1024/1024))MB"
          
          echo "=== Building ISO ==="
          cd /tmp
          
          # Copy kernel from rootfs
          cp "$(find /w/rootfs/boot -name 'vmlinuz-*' | tail -1)" vmlinuz
          KVER=$(ls /w/rootfs/lib/modules/ | tail -1)
          
          # Download static busybox
          wget -qO busybox \
            https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox
          chmod +x busybox
          
          # Create initramfs structure
          mkdir -p initramfs/{bin,sbin,proc,sys,dev,tmp,run,mnt,etc,lib/modules,lib64}
          
          # Install busybox
          cp busybox initramfs/bin/busybox
          
          # Create busybox symlinks
          for cmd in sh mount umount cat ls cp mv rm mkdir mknod chmod chown ln \
                     grep sed awk cut sort head tail wc tr find xargs \
                     wget ping ip ifconfig route modprobe insmod lsmod \
                     sleep sync reboot poweroff switch_root; do
            ln -sf busybox initramfs/bin/$cmd 2>/dev/null || true
          done
          
          for cmd in init mdev udhcpc; do
            ln -sf ../bin/busybox initramfs/sbin/$cmd 2>/dev/null || true
          done
          
          # Copy firmware
          mkdir -p initramfs/lib/firmware
          cp -r /lib/firmware/* initramfs/lib/firmware/ 2>/dev/null || true
          
          # Copy kernel modules
          mkdir -p initramfs/lib/modules/$KVER
          for module_dir in drivers/net drivers/virtio kernel/net kernel/drivers/virtio \
                           fs/isofs fs/squashfs fs/overlayfs; do
            find /w/rootfs/lib/modules/$KVER/$module_dir -name "*.ko" 2>/dev/null | \
            while read module; do
              relative_path="${module#/w/rootfs/lib/modules/$KVER/}"
              mkdir -p "initramfs/lib/modules/$KVER/$(dirname $relative_path)"
              cp "$module" "initramfs/lib/modules/$KVER/$relative_path"
            done
          done
          
          # Copy module dependency files
          cp /w/rootfs/lib/modules/$KVER/modules.* initramfs/lib/modules/$KVER/ 2>/dev/null || true
          
          # Copy additional binaries
          for binary in /usr/sbin/unsquashfs /sbin/parted /sbin/wpa_supplicant; do
            if [ -f "$binary" ]; then
              target_dir="initramfs$(dirname $binary)"
              mkdir -p "$target_dir"
              cp "$binary" "$target_dir/"
              
              ldd "$binary" 2>/dev/null | grep -oE '/[^ ]+' | while read lib; do
                if [ -f "$lib" ]; then
                  lib_dir="initramfs$(dirname $lib)"
                  mkdir -p "$lib_dir"
                  cp "$lib" "$lib_dir/" 2>/dev/null || true
                fi
              done
            fi
          done
          
          # Copy dynamic linker
          [ -f /lib64/ld-linux-x86-64.so.2 ] && \
            cp /lib64/ld-linux-x86-64.so.2 initramfs/lib64/
          
          # DNS configuration
          echo "nameserver 8.8.8.8" > initramfs/etc/resolv.conf
          
          # Create init script for live boot
          cat > initramfs/init << 'INIT_SCRIPT'
          #!/bin/busybox sh
          
          set +m
          set +e
          trap "" EXIT HUP INT TERM
          
          export PATH=/bin:/sbin:/usr/bin:/usr/sbin
          export LD_LIBRARY_PATH=/lib:/lib64:/usr/lib
          
          echo "Starting Cybr K9 Live System..."
          
          # Mount filesystems
          mount -t proc none /proc 2>/dev/null
          mount -t sysfs none /sys 2>/dev/null
          mount -t devtmpfs none /dev 2>/dev/null
          mkdir -p /dev/pts /dev/shm /tmp /run
          mount -t devpts none /dev/pts 2>/dev/null
          mount -t tmpfs none /tmp 2>/dev/null
          mount -t tmpfs none /run 2>/dev/null
          
          mdev -s 2>/dev/null
          hostname cybr-k9 2>/dev/null
          
          # Load essential modules
          modprobe loop 2>/dev/null
          modprobe squashfs 2>/dev/null
          modprobe overlay 2>/dev/null
          
          # Find and mount the ISO
          for dev in /dev/sr* /dev/sd*; do
            [ -b "$dev" ] || continue
            mount -o ro "$dev" /mnt 2>/dev/null && break
          done
          
          if [ -f /mnt/live/filesystem.squashfs ]; then
            echo "Found filesystem, booting live system..."
            
            # Create mount points
            mkdir -p /squash /overlay /newroot
            
            # Mount squashfs
            mount -t squashfs -o loop,ro /mnt/live/filesystem.squashfs /squash
            
            # Create overlay
            mkdir -p /overlay/upper /overlay/work
            mount -t overlay overlay -o lowerdir=/squash,upperdir=/overlay/upper,workdir=/overlay/work /newroot
            
            # Move mounts
            mount --move /dev /newroot/dev
            mount --move /proc /newroot/proc
            mount --move /sys /newroot/sys
            
            # Switch to new root
            exec switch_root /newroot /sbin/init
          fi
          
          echo "ERROR: Could not find filesystem"
          exec /bin/sh
          INIT_SCRIPT
          
          chmod +x initramfs/init
          
          # Create initramfs
          cd initramfs
          find . | cpio -o -H newc 2>/dev/null | gzip -9 > /tmp/initrd.gz
          cd /tmp
          
          echo "Initramfs: $(du -h initrd.gz | cut -f1)"
          
          # Prepare ISO structure
          rm -rf iso
          mkdir -p iso/boot/grub iso/live
          cp vmlinuz initrd.gz iso/boot/
          cp /w/filesystem.squashfs iso/live/
          
          # GRUB config
          cat > iso/boot/grub/grub.cfg << 'GRUB_CFG'
          set timeout=5
          set default=0
          
          menuentry "Cybr K9 Live" {
            linux /boot/vmlinuz quiet splash
            initrd /boot/initrd.gz
          }
          
          menuentry "Cybr K9 Live (Safe Mode)" {
            linux /boot/vmlinuz nomodeset
            initrd /boot/initrd.gz
          }
          GRUB_CFG
          
          # BIOS boot setup
          mkdir -p iso/boot/grub/i386-pc
          cp /usr/lib/grub/i386-pc/*.mod iso/boot/grub/i386-pc/ 2>/dev/null || true
          cp /usr/lib/grub/i386-pc/*.lst iso/boot/grub/i386-pc/ 2>/dev/null || true
          
          cat /usr/lib/grub/i386-pc/cdboot.img > iso/boot/grub/bios.img
          grub-mkimage \
            -d /usr/lib/grub/i386-pc \
            -O i386-pc \
            -o core.img \
            -p /boot/grub \
            biosdisk iso9660
          cat core.img >> iso/boot/grub/bios.img
          rm core.img
          
          # EFI boot setup
          mkdir -p iso/EFI/BOOT
          grub-mkstandalone \
            -d /usr/lib/grub/x86_64-efi \
            -O x86_64-efi \
            --modules="part_gpt part_msdos iso9660" \
            --locales="" \
            --fonts="" \
            -o iso/EFI/BOOT/BOOTX64.EFI \
            "boot/grub/grub.cfg=iso/boot/grub/grub.cfg"
          
          # EFI image
          dd if=/dev/zero of=iso/efi.img bs=1M count=10 2>/dev/null
          mkfs.vfat iso/efi.img >/dev/null 2>&1
          mmd -i iso/efi.img ::/EFI ::/EFI/BOOT
          mcopy -i iso/efi.img iso/EFI/BOOT/BOOTX64.EFI ::/EFI/BOOT/
          
          # Create hybrid ISO
          xorriso -as mkisofs -o "/w/${ISO}.iso" \
            -r -J -joliet-long \
            -b boot/grub/bios.img \
            -no-emul-boot \
            -boot-load-size 4 \
            -boot-info-table \
            --grub2-boot-info \
            --grub2-mbr /usr/lib/grub/i386-pc/boot_hybrid.img \
            -eltorito-alt-boot \
            -e efi.img \
            -no-emul-boot \
            -isohybrid-gpt-basdat \
            iso/ 2>&1 | tail -5
          
          # Checksums
          cd /w
          sha256sum "${ISO}.iso" > "${ISO}.iso.sha256"
          
          echo ""
          echo "═══ Build Complete ═══"
          ls -lh *.iso
          BUILD_SCRIPT_EOF
          
          chmod +x build.sh

      - name: Run build in Docker
        run: |
          docker run --rm --privileged \
            -v "$PWD:/w" \
            -e RUN_NUM="${{ github.run_number }}" \
            debian:bookworm \
            /w/build.sh

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: "cybr-k9-build-${{ github.run_number }}"
          path: |
            *.iso
            *.iso.sha256
          retention-days: 7

  upload:
    runs-on: ubuntu-latest
    needs: build
    if: ${{ github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main' }}

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: "cybr-k9-build-${{ github.run_number }}"

      - name: Upload to SourceForge
        env:
          SF_USER: ${{ secrets.SF_USER }}
          SF_PASS: ${{ secrets.SF_PASS }}
        run: |
          [ -z "$SF_USER" ] && exit 0
          
          sudo apt-get update
          sudo apt-get install -y sshpass rsync
          
          for iso_file in *.iso; do
            for attempt in 1 2 3; do
              sshpass -p "$SF_PASS" rsync -avP \
                -e "ssh -o StrictHostKeyChecking=no" \
                "$iso_file" \
                "$SF_USER@frs.sourceforge.net:/home/frs/project/wolfos/gaming/k9/" \
                && break
              sleep 30
            done
          done
